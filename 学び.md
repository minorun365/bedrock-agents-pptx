# Bedrock Agents を AWS Amplify Gen2 から使う際のガイド

このドキュメントは、AWS Amplify Gen2 のフロントエンドアプリケーションから Amazon Bedrock Agents を呼び出す際の考慮点と実装パターンをまとめたものです。

---

## 1. アーキテクチャ概要

```
┌─────────────────┐      ┌──────────────────┐      ┌─────────────────┐
│   React App     │─────▶│  Cognito Auth    │─────▶│ Bedrock Agents  │
│   (Vite)        │      │  (Identity Pool) │      │                 │
└─────────────────┘      └──────────────────┘      └─────────────────┘
        │                        │
        │                        ▼
        │                ┌──────────────────┐
        └───────────────▶│ amplify_outputs  │
                         │     .json        │
                         └──────────────────┘
```

- **Amplify Gen2**: バックエンド（認証）を定義・デプロイ
- **Cognito Identity Pool**: 認証済みユーザーにAWSクレデンシャルを発行
- **Bedrock Agents Runtime API**: エージェントの呼び出し

---

## 2. IAM権限の設定（重要）

### 問題
Cognito Identity Pool の Authenticated Role には、デフォルトで Bedrock Agents の呼び出し権限がありません。

### エラー例
```
User: arn:aws:sts::XXXXXXXXXXXX:assumed-role/amplify-xxx-authenticatedU-xxx/CognitoIdentityCredentials
is not authorized to perform: bedrock:InvokeAgent on resource: arn:aws:bedrock:us-east-1:XXXXXXXXXXXX:agent-alias/AGENT_ID/ALIAS_ID
because no identity-based policy allows the bedrock:InvokeAgent action
```

### 解決策
`amplify/backend.ts` で Authenticated Role に IAM ポリシーを追加：

```typescript
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { PolicyStatement, Effect } from 'aws-cdk-lib/aws-iam';

const backend = defineBackend({
  auth,
  data,
});

// Authenticated RoleにBedrock Agentの呼び出し権限を追加
backend.auth.resources.authenticatedUserIamRole.addToPrincipalPolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: ['bedrock:InvokeAgent'],
    resources: ['arn:aws:bedrock:us-east-1:*:agent-alias/*/*'],
  })
);
```

### 権限のスコープ
- 最小権限の原則に従い、特定のエージェントのみに制限することも可能：
  ```typescript
  resources: [`arn:aws:bedrock:us-east-1:${accountId}:agent-alias/${agentId}/${aliasId}`]
  ```

---

## 3. フロントエンドからの認証情報取得

### Amplify v6 での認証情報取得

```typescript
import { fetchAuthSession } from 'aws-amplify/auth';

const { credentials } = await fetchAuthSession();

const client = new BedrockAgentRuntimeClient({
  region: 'us-east-1',
  credentials,  // Cognito Identity Pool から取得したクレデンシャル
});
```

### 注意点
- `fetchAuthSession()` は認証済みユーザーに対してのみ有効
- クレデンシャルは一時的なもの（STS）で、自動的にリフレッシュされる
- Amplify UI の `<Authenticator>` コンポーネントを使うと認証フローが簡単

---

## 4. Bedrock Agents API 呼び出し

### InvokeAgent の基本

```typescript
import {
  BedrockAgentRuntimeClient,
  InvokeAgentCommand,
} from '@aws-sdk/client-bedrock-agent-runtime';

const command = new InvokeAgentCommand({
  agentId: 'AGENT_ID',
  agentAliasId: 'ALIAS_ID',
  sessionId: 'unique-session-id',  // 会話を継続するためのセッションID
  inputText: 'ユーザーの質問',
  enableTrace: true,  // トレース情報を取得
});

const response = await client.send(command);
```

### ストリーミングレスポンスの処理

```typescript
for await (const event of response.completion) {
  // テキストチャンク
  if (event.chunk?.bytes) {
    const text = new TextDecoder('utf-8').decode(event.chunk.bytes);
    console.log(text);
  }

  // トレース情報
  if (event.trace?.trace) {
    console.log('Trace:', event.trace.trace);
  }
}
```

---

## 5. トレース情報の構造

`enableTrace: true` を設定すると、エージェントの内部動作を追跡できます。

### トレースの種類

| トレースタイプ | 説明 |
|---------------|------|
| `preProcessingTrace` | 入力の前処理（ガードレールチェックなど） |
| `orchestrationTrace` | メインのオーケストレーション処理 |
| `postProcessingTrace` | 出力の後処理 |

### orchestrationTrace の詳細

```typescript
orchestrationTrace: {
  // LLMへの入力
  modelInvocationInput: {
    text: string,
    traceId: string,
    type: string
  },

  // LLMからの出力
  modelInvocationOutput: {
    rawResponse: { content: string },
    traceId: string
  },

  // エージェントの思考過程
  rationale: {
    text: string,  // "ユーザーは〇〇を求めている。△△アクションを実行する。"
    traceId: string
  },

  // アクション実行の入力
  invocationInput: {
    actionGroupInvocationInput: {
      actionGroupName: string,
      apiPath: string,
      httpMethod: string,
      parameters: object[]
    },
    invocationType: 'ACTION_GROUP' | 'KNOWLEDGE_BASE' | etc,
    traceId: string
  },

  // アクション実行の結果
  observation: {
    actionGroupInvocationOutput: {
      text: string  // アクションの実行結果
    },
    traceId: string,
    type: 'ACTION_GROUP' | 'KNOWLEDGE_BASE' | 'FINISH'
  }
}
```

### トレースのパース例

```typescript
const parseTrace = (trace: unknown): TraceInfo | null => {
  if (!trace || typeof trace !== 'object') return null;
  const t = trace as Record<string, unknown>;

  if (t.orchestrationTrace) {
    const ot = t.orchestrationTrace as Record<string, unknown>;

    if (ot.rationale) {
      const rationale = ot.rationale as Record<string, unknown>;
      return {
        type: 'Reasoning',
        detail: String(rationale.text || '思考中...'),
      };
    }

    if (ot.invocationInput) {
      const input = ot.invocationInput as Record<string, unknown>;
      const actionGroup = input.actionGroupInvocationInput as Record<string, unknown>;
      return {
        type: 'Action',
        detail: `アクション実行: ${actionGroup?.actionGroupName || 'unknown'}`,
      };
    }

    // ... 他のトレースタイプ
  }

  return null;
};
```

---

## 6. 環境変数の設定

### Vite での環境変数

Vite では `VITE_` プレフィックスが必要：

```env
# .env
VITE_AGENT_ID=SXKBZKJRGH
VITE_AGENT_ALIAS_ID=4MJH3GCO9J
VITE_AWS_REGION=us-east-1
```

### TypeScript での型定義

```typescript
// vite-env.d.ts に追加（オプション）
interface ImportMetaEnv {
  readonly VITE_AGENT_ID: string
  readonly VITE_AGENT_ALIAS_ID: string
  readonly VITE_AWS_REGION: string
}
```

### 使用方法

```typescript
const AGENT_ID = import.meta.env.VITE_AGENT_ID;
const AGENT_ALIAS_ID = import.meta.env.VITE_AGENT_ALIAS_ID;
const AWS_REGION = import.meta.env.VITE_AWS_REGION || 'us-east-1';
```

---

## 7. 必要なパッケージ

```json
{
  "dependencies": {
    "@aws-amplify/ui-react": "^6.x",
    "@aws-sdk/client-bedrock-agent-runtime": "^3.x",
    "aws-amplify": "^6.x",
    "react": "^19.x",
    "react-dom": "^19.x"
  }
}
```

---

## 8. セッション管理

### セッションIDの重要性

- 同じ `sessionId` を使用すると、会話のコンテキストが維持される
- 新しい会話を開始する場合は、新しい `sessionId` を生成する

```typescript
// 新しい会話を開始
const sessionIdRef = useRef(crypto.randomUUID());

const handleNewChat = () => {
  sessionIdRef.current = crypto.randomUUID();
  setMessages([]);
};
```

---

## 9. エラーハンドリング

### よくあるエラー

| エラー | 原因 | 解決策 |
|--------|------|--------|
| `not authorized to perform: bedrock:InvokeAgent` | IAM権限不足 | backend.ts で権限追加 |
| `Agent not found` | Agent ID/Alias ID が間違っている | 環境変数を確認 |
| `Credential is missing` | 認証されていない | Authenticator でラップ |

### エラーハンドリング例

```typescript
try {
  const response = await client.send(command);
  // 処理
} catch (err) {
  if (err instanceof Error) {
    if (err.message.includes('not authorized')) {
      console.error('IAM権限エラー: Bedrock Agentの呼び出し権限がありません');
    } else if (err.message.includes('Agent not found')) {
      console.error('エージェントが見つかりません: IDを確認してください');
    } else {
      console.error('予期しないエラー:', err.message);
    }
  }
}
```

---

## 10. 開発ワークフロー

### Amplify Sandbox の使用

```bash
# 1. AWS認証
aws login

# 2. Sandboxを起動（バックエンドをデプロイ）
npx ampx sandbox

# 3. 別ターミナルでフロントエンド開発サーバー起動
npm run dev
```

### Sandbox の特徴
- ファイル変更を監視して自動で再デプロイ
- `amplify_outputs.json` を自動生成
- 開発者ごとに独立した環境（`--identifier` で指定可能）

---

## まとめ

Amplify Gen2 から Bedrock Agents を使う際のポイント：

1. **IAM権限**: `backend.ts` で `bedrock:InvokeAgent` 権限を明示的に追加
2. **認証情報**: `fetchAuthSession()` で Cognito からクレデンシャルを取得
3. **トレース**: `enableTrace: true` でエージェントの内部動作を可視化
4. **環境変数**: Vite では `VITE_` プレフィックスが必要
5. **セッション管理**: `sessionId` で会話コンテキストを維持
