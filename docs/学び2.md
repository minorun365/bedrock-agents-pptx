# Bedrock Agents + Amplify フロントエンド開発の学び

## 概要

React + Vite + AWS Amplify Gen2 を使用して、Bedrock Agents を呼び出すチャットフロントエンドを開発した際の学びをまとめる。

## 技術スタック

- React 18 + TypeScript
- Vite
- AWS Amplify Gen2（認証）
- AWS SDK for JavaScript v3（Bedrock Agent Runtime）

## Amplify Gen2 認証の設定

### 1. 基本設定

```typescript
// main.tsx
import { Amplify } from 'aws-amplify'
import outputs from '../amplify_outputs.json'
Amplify.configure(outputs)
```

### 2. Authenticator コンポーネントの使用

```typescript
import { Authenticator } from '@aws-amplify/ui-react'
import '@aws-amplify/ui-react/styles.css'

function App() {
  return (
    <Authenticator>
      {({ signOut }) => (
        // アプリケーション本体
      )}
    </Authenticator>
  )
}
```

### 3. IAM ポリシーの設定

Cognito 認証済みユーザーが Bedrock Agent を呼び出せるように、`amplify/backend.ts` で IAM ポリシーを追加する必要がある。

```typescript
import { PolicyStatement, Effect } from 'aws-cdk-lib/aws-iam';

backend.auth.resources.authenticatedUserIamRole.addToPrincipalPolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: ['bedrock:InvokeAgent'],
    resources: ['arn:aws:bedrock:us-east-1:*:agent-alias/*/*'],
  })
);
```

## Bedrock Agent の呼び出し

### 1. 認証情報の取得

```typescript
import { fetchAuthSession } from 'aws-amplify/auth'

const { credentials } = await fetchAuthSession()
```

### 2. クライアントの作成とエージェント呼び出し

```typescript
import {
  BedrockAgentRuntimeClient,
  InvokeAgentCommand,
} from '@aws-sdk/client-bedrock-agent-runtime'

const client = new BedrockAgentRuntimeClient({
  region: AWS_REGION,
  credentials,
})

const command = new InvokeAgentCommand({
  agentId: AGENT_ID,
  agentAliasId: AGENT_ALIAS_ID,
  sessionId: sessionId,
  inputText: prompt,
  enableTrace: true,  // トレース情報を有効化
})

const response = await client.send(command)
```

### 3. ストリーミングレスポンスの処理

```typescript
for await (const event of response.completion) {
  // テキストチャンク
  if (event.chunk?.bytes) {
    const text = new TextDecoder('utf-8').decode(event.chunk.bytes)
    fullResponse += text
  }

  // トレース情報
  if (event.trace?.trace) {
    // トレースの処理
  }
}
```

## トレース情報の構造

Bedrock Agents のトレースには以下の種類がある：

### 1. orchestrationTrace

エージェントのオーケストレーション（思考・行動）に関するトレース。

- **rationale**: エージェントの思考内容
  ```json
  {
    "orchestrationTrace": {
      "rationale": {
        "text": "KAGのみのるんについて資料を作成いたします..."
      }
    }
  }
  ```

- **invocationInput**: アクション（Lambda関数など）の実行情報
  ```json
  {
    "orchestrationTrace": {
      "invocationInput": {
        "actionGroupInvocationInput": {
          "function": "search-web",
          "parameters": [
            { "name": "query", "value": "KAG みのるん" }
          ]
        }
      }
    }
  }
  ```

- **observation**: 実行結果の観測
  - `actionGroupInvocationOutput`: Lambda関数の実行結果（表示不要なことが多い）
  - `finalResponse`: 最終応答（ストリーミングと重複するため表示不要）

- **modelInvocationOutput**: モデルの出力（最終応答と重複することが多い）

### 2. preProcessingTrace

入力の前処理に関するトレース。「入力を確認中...」などの表示に使用。

### 3. postProcessingTrace

出力の後処理に関するトレース（通常は表示不要）。

## React でのストリーミング状態管理の注意点

### 問題: メッセージが消える・順番が入れ替わる

ストリーミング中に `useState` で状態を更新すると、Reactの非同期な状態更新により、メッセージが消えたり順番が入れ替わることがある。

### 解決策: useRef + カウンターによる強制再レンダリング

```typescript
const messagesRef = useRef<Message[]>([])
const [renderKey, setRenderKey] = useState(0)

const addMessage = useCallback((message: Message) => {
  messagesRef.current.push(message)
  setRenderKey(prev => prev + 1)
}, [])
```

- `messagesRef.current.push()` で直接配列に追加（同期的）
- `renderKey` の変更で再レンダリングをトリガー
- レンダリング時は `messagesRef.current` を直接参照

## 環境変数

Vite では `VITE_` プレフィックスが必要。

```env
VITE_AGENT_ID=XXXXXXXXXX
VITE_AGENT_ALIAS_ID=YYYYYYYYYY
VITE_AWS_REGION=us-east-1
```

```typescript
const AGENT_ID = import.meta.env.VITE_AGENT_ID
```

## CSS のポイント

### Authenticator の中央配置

```css
[data-amplify-authenticator] {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}
```

### トレース表示のスタイル分け

Lambda実行中のトレースは薄いグレー背景で区別：

```css
.message.trace-action .message-content {
  background: #f9fafb;
  color: #1a1a2e;
}
```

## ハマりポイントまとめ

1. **IAM権限**: Cognito Identity Pool の認証済みロールに `bedrock:InvokeAgent` 権限が必要
2. **トレースの重複**: `modelInvocationOutput` や `observation.finalResponse` は最終応答と重複するため表示しない
3. **状態管理**: ストリーミング中の `useState` 更新は問題を起こしやすい。`useRef` を使用する
4. **「考え中」表示**: トレースが表示されている間は非表示にする条件が必要
